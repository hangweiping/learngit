# JS高程读书笔记--第六章

## 理解对象

创建自定义对象的方式有创建一个Object实例，然后为它添加属性和方法。还可用创建对象字面量的方式

### 属性类型

ECMAScript在定义只有内部采用的特性时，描述了属性的各种特征。

ECMAScript在定义只有内部采用的特性时，描述了属性的各种特征。
ECMAScript中有两种属性：**数据属性**和**访问器属性**。在JS中不能直接访问它们。

#### 数据属性

数据属性包含一个数据值的位置。在这个位置可以读取和写入值。

- `[[Configurable]]`：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认值为**true**；
- `[[Enumerable]]`：表示能否通过for-in循环返回属性。默认值为**true**；
- `[[Writable]]`：表示能否修改属性的值。默认值为**true**；
- `[[Value]]`：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。默认值为**undefined**；

要修改属性默认的特性，必须使用ES5的`Object.defineProperty()`方法。这个方法接收三个参数：**属性所在的对象**、**属性的名字**和**一个描述符对象**。在调用这个方法时，如果不指定，configurable、enumerable和writable特性的默认值都是false；

> 一旦把属性定义为不可配置的，就不能再把它变回可配置的。

#### 访问器属性

访问器属性不包含数据值；他们包含一对getter和setter函数（这两个函数都不是必须的）。在读取访问器属性时，会调用getter函数，这个函数负责返回有效值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。

- `[[Configurable]]`：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。默认值为**true**；
- `[[Enumerable]]`：表示能否通过for-in循环返回属性。默认值为**true**；
- `[[Get]]`：在读取属性时调用的函数。默认值为**undefined**;
- `[[Set]] `：在写入属性时调用的函数。默认值为**undefined**；

> 访问器属性不能直接定义，必须使用`Object.defineProperty()`来定义。

不一定非要同时指定getter和setter。只指定getter意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了getter函数的属性会抛出错误。类似的，只指定setter函数的属性也不能读，否则在非严格模式下会返回undefined，而在严格模式下会抛出错误。

### 定义多个属性

可以利用ES5定义的`Object.defineProperties()`方法通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。

### 读取属性的特性

使用ES5的`Object.getOwnPropertyDescriptor()`方法，可以取得给定属性的描述符。这个方法接收两个参数：**属性所在对象**和**要读取其描述符的属性名称**，返回值是一个**对象**。

## 创建对象

### 工厂模式

这种模式抽象了创建具体对象的过程。开发人员发明了一种函数，用函数来封装以特定接口创建对象的细节。

```
function createPerson(name,age,job){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        console.log(this.name);
    }
    return o;
}
var person1 = createPerson('junyan','25','FE');
```

工厂模式虽然解决了创建多个相似对象的问题，但却**没有解决对象识别**的问题（即怎样知道一个对象的类型）

### 构造函数模式

可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。

```
function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function(){
        console.log(this.name);
    };
}
var person1 = new Person('junyan','25','FE')
```

这种方式与工厂模式存在以下不同：

- 没有显式的创建对象；
- 直接将属性和方法赋给了this对象；
- 没有return语句；

要创建Person新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历以下4个步骤：

1. 创建一个新对象；
2. 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；
3. 执行构造函数中的代码（为这个新对象添加属性）；
4. 返回新对象；

实例都有一个`constructor`（构造函数）属性，该属性指向Person。对象的这个属性最初是用来标识对象类型的。但是，提到检测对象类型，还是`instanceof`操作符要更可靠一些。

> 创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型

#### 将构造函数当做函数

- 构造函数与其他函数的唯一区别，就在于调用它们的方式不同。任何函数，只要通过new操作符来调用，那它就可以作为构造函数；
- 不使用new操作符调用，属性和方法都被添加给window对象

#### 构造函数的问题

- 使用构造函数的主要问题就是每个方法都要在每个实例上重新创建一遍。
- 不同实例上的同名函数是不相等的，可以通过把函数定义转移到构造函数外部来解决。

### **原型模式!!**

我们创建的每个函数都有一个`prototype`（原型）属性，这个属性是**一个指针**，指向一个**对象**，而这个对象的用途是**包含可以由特定类型的所有实例共享的属性和方法**

> prototype就是通过调用构造函数而创建的那个**对象实例的原型对象**

使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。

> 构造函、原型和实例的**关系**：每个构造函数构造函数都有一个原型对象`(prototype)`，原型对象都包含一个指向构造函数的指针`(constructor)`，而实例都包含一个指向原型对象的内部指针`(__proto__)`

#### **理解原型对象!!!**

1. 只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个`prototype`属性，这个属性**指向函数的原型对象**。

   只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个`prototype`属性，这个属性**指向函数的原型对象**。
   所有原型对象都会自动获得一个`constructor`（构造函数）属性，这个属性包含一个**指向prototype属性所在函数的指针**。例：`Person.prototype.constructor = Person`。

创建了自定义的构造函数之后，其原型对象**默认只会取得constructor属性**；至于其他方法都是从Object继承而来的。

> 原型最初只包含`constructor`属性，而该属性也是共享的，因此可以通过**对象实例访问**

1. 当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性）ECMA叫`[[Prototype]]`，**指向构造函数的原型对象**，高级浏览器在每个对象上都支持一个属性`__proto__`。

> 注：这个连接存在于**实例与构造函数的原型对象之间**，不存在于实例与构造函数之间。

- 可以通过`isPrototypeOf()`方法来确定对象之间是否存在这种关系

  可以通过`isPrototypeOf()`方法来确定对象之间是否存在这种关系
  `Person.prototype.isPrototypeOf(person1); // true`;

- ES5新增了一个方法，叫`Object.getPrototypeOf()`，这个方法返回`[[Prototype]]`的值。

  ES5新增了一个方法，叫`Object.getPrototypeOf()`，这个方法返回`[[Prototype]]`的值。
  `Object.getPrototypeOf(person1) == Person.prototype`。

使用这个方法可以方便的取得一**个对象的原型**；

1. 当为对象实例添加一个属性时，这个属性就会**屏蔽原型对象中的同名属性**；换句话说，添加这个属性只会阻止我们访问原型中的那个属性，但**不会修改那个属性**。即使将这个属性设置为null，也只会在实例中设置这个属性，而不会恢复其指向原型的链接。不过，可以通过使用**delete操作符**则可以完全删除实例属性，从而让我们能够重新访问原型中的属性。

> 使用**hasOwnProperty()**方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（从Object继承而来）只在给定属性存在于对象实例中，在返回true。

#### 原型与in操作符

- 单独使用in时，in操作符会在通过对象能够访问给定属性时返回true，**无论该属性存在于实例中还是原型中**。
- 同时使用`hasOwnProperty()`方法和in操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中
- 在使用for-in循环时，返回的是所有能够通过对象**访问的、可枚举的**属性，其中即包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性的实例属性也会在for-in循环中返回。
- 要取得对象上**可枚举的实例属性**，可以使用ES5的`Object.keys()`，这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。
- 如果想得到所有实例属性，无论它是否可枚举，都可以使用`Object.getOwnPropertyNames()`

#### 更简单的原型语法

可以用一个包含所有属性和方法的**对象字面量**来重写整个原型对象

```
Person.prototype = {
    name:'junyan',
    job:'FE'
}
```

- 但是这样`constructor`属性就不再指向Person，这种语法实际上完全**重写**了默认的`prototype`对象，因此`constructor`属性就变成了新对象的`constructor`属性，不再指向Person，而是**指向Object**。此时`instanceof`还能返回正确的结果。
- 如果`constructor`属性很重要，可以特意设定将它设置回适当的值，但这种方式重设`constructor`属性会导致它的`[[Enumerable]]`特性被设置为true，因为默认情况下原生的`constructor`属性是不可枚举的。可以使用ES5的`Object.defineProperty()`

#### 原型的动态性

1. 我们对原型对象所做的任何修改都能够**立即**从实例上反映出来，即使是先创建了实例后修改原型也照样如此，因为实例与原型之间的连接只不过是一个**指针**，而非一个副本；
2. 但是如果**重写了整个原型对象**，就不一样。调用构造函数时会为实例添加一个指向最初原型的`[[Prototye]]`指针（__proto__），而把原型修改为另一个对象就等于**切断了构造函数与最初原型之间的联系**
3. 重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系，它们引用的仍然是**最初的原型**

> 实例中的指针**仅指向原型，而不指向构造函数**

#### 原生对象的原型

1. 所有原生引用类型（Object、Array、String等）都在其**构造函数的原型**上定义了方法；
2. 通过原生对象的原型，不仅可以取得**所有默认方法的引用**，而且也可以**定义新方法**。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。（不建议）；

#### 原型对象的问题

原型中所有属性被实例共享，对于基本类型值的属性，通过在实例上添加一个同名属性，可以隐藏原型中的对应属性，但对于引用类型值的属性来说，实例上修改其值，在所有其他实例中都会反映出来，所以基本**不单独使用原型模式**。

### 组合使用构造函数模式和原型模式

构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性。

```
function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.friends = ["xiaohua","hanghang"]
}
Person.prototype = {
    constructor:Person,
    sayName:function(){
        console.log(this.name);        
    }
}
```

## 继承

ECMAScript只支持实现继承，而且实现继承主要是依靠原型链来实现。

### 原型链

原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。

如果让原型对象等于另一个类型的实例，此时的原型对象将包含一个**指向另一个原型的指针**`(__proto__)`相应地，另一个原型中也包含着一个指向另一个构造函数的指针。若另一个原型又是另一个类型的实例，上述关系依然成立，如此层层递进，就构成了实例与原型的链条。

> 在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到**原型链末端才会停下来**

#### 默认的原型

所有引用类型默认都继承了**Object**，而这个继承也是通过原型链实现的。所有函数的默认原型都是Object实例，因此默认原型都会包含一个**内部指针**`(__proto__)`，指向Object.prototype。这也正是所有自定义类型都会继承`toString()`、`valueOf()`等**默认方法**的根本原因

#### 确定原型和实例的关系

1. 第一种方式是使用`instanceof`操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true。
2. 第二种方式是使用`isPrototypeOf()`方法。同样，只要是**原型链中出现过的原型**，都可以说是该原型链所派生的实例的原型，因此这个方法也会返回true.

#### 谨慎地定义方法

- 给原型添加方法一定要放在替换原型的语句之后，重写的方法会屏蔽原来的那个方法
- 在通过原型链实现继承时，**不能使用对象字面量创建原型方法**。因为这样做就会重写原型链。

#### 原型链的问题

实践中**很少会单独使用原型链**

- 在通过原型来实现继承时，原型实际上会变成**另一个类型的实例**，原先的实例属性也就顺理成章的变成了现在的原型属性
- 在创建子类型的实例时，不能向超类型的构造函数中传递参数。应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。

### 借用构造函数

在子类型构造函数的内部调用超类型构造函数，可以通过使用`apply()`和`call()`方法在新创建的对象上执行构造函数。

```
function SubType(){
    SuperType.call(this);
}
```

这一年就会在新的Subtype对象上执行`SuperType()`函数中定义的所有对象初始化代码。

1. 可以在子类型构造函数中向超类型构造函数传递参数

```
function SubType(){
    SuperType.call(this,'junyan');
}
```

1. 如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起，而且在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。

### 组合继承

有时也叫作伪经典继承，使用**原型链**实现对原型属性和方法的继承，而通过借用**构造函数**来实现对实例属性的继承。这样既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。

> `instanceof`和`isPrototypeof()`也能够用于识别基于组合继承创建的对象

组合继承最大的问题就是无论什么情况下，都会调用**两次超类型构造函数**：一次是在**创建子类原型**的时候，另一次是在**子类型构造函数内部**。

### 原型式继承

这个方法没有使用严格意义上的构造函数，是基于已有的对象创建新对象，同时还不必因此创建自定义类型。

```
function object(o){
    function F(){}
    F.prototype = o;
    return new F();
}
```

> 严格上讲，`object()`对传入其中的对象执行了一次**浅复制**

ES5通过新增`Object.create()`方法规范了原型式继承。这个方法接收两个参数：**一个用作新对象原型的对象**和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，`Object.create()`与`object()`方法的行为相同。

ES5通过新增`Object.create()`方法规范了原型式继承。这个方法接收两个参数：**一个用作新对象原型的对象**和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，`Object.create()`与`object()`方法的行为相同。
只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的，不要忘了，包含**引用类型值**的属性始终都会**共享相应的值**，就像使用原型模式一样。

### 寄生式继承

创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。

```
function createAnother(original){
    var clone = object(original);
    clone.sayHi = function(){
        console.log('Hi');
    };
    return clone;
}
```

在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。任何能够返回新对象的函数都适用于这个模式

### 寄生式组合继承

所谓寄生组合式继承，即通过借用**构造函数**来继承属性，通过**原型链的混成形式**来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是**使用寄生式继承来继承超类型的原型**，然后再将结果指定给**子类型的原型**

```
function inheritPrototype(subType,superType){
    var prototype = Object(superType.prototype);
    prototype.constructor = subType;
    subType.prototype = prototype;
}
```

1. 第一步是创建**超类型原型的一个副本**
2. 第二部是为创建的副本**添加constructor属性**，从而弥补因重写原型而失去的默认的constructor属性。
3. 将新创建的对象（即副本）赋值给子类型的原型

> 这种继承的高效率体现在它只调用了**一次超类型构造函数**，并且因此避免了在子类型.prototype上面创建不必要的、多余的属性。于此同事，原型链还能保持不变；因此还能正常使用`instanceof()`和`isPrototypeOf()`